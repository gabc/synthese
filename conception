* Planification
  
** Présentation générale
   Ce logiciel permet de simuler un écosystême.
   
   Le concept de ce simulateur consiste à créer une maquette virtuelle d'un environnement réduit et simpliste. Vous devrez créer de petits êtres virtuels ayant des caractéristiques différentes et devant interagir dans l'environnement où ils seront insérés. Principalement, il devra y avoir des proies et des prédateurs interagissant les uns avec les autres. L'équilibre de ce petit écosystème sera important pour que toutes les races puissent vivre ensemble.
   
** Présentation détaillée
   
   Ce projet se veut une création d'un `framework' pour la création d'un écosysteme.
   En effet, chacune des créatures sera chargée a partir d'une librairie externe.
   Ceci permettera un dynamisme et une plus grande libértée pour ces créatures.
   Par contre, ce choix oblige un plus grand niveau d'abstraction au niveau du design.
   En effet, comme il sera impossible d'assumer la présence d'aucune autre créature.
   
   Par exemple, si dans une simulation il y a des lapins, il est impossible d'assumer la présence de loup ou autre prédateur.
   Et a l'inverse, un loup ne peut pas assumer la présence de proie, que ce soit lapin, ou autre.
   Chaque créature devra donc apprendre ce qu'il peut et/ou pas faire dans l'environement dans lequel il est placé.
   
   Pour aider ce processus. Les créatures sont en deux types et deux cathégories.
   C'est-a-dire:
   Plante ou Animal puis
   Herbivore et Carnivore.
   
   Donc un animal carnivore va pouvoir tenter de manger un autre animal.
   Et etc pour les autres.
   
   De plus, pour aider les créatures a savoir s'ils peuvent manger une autre.
   Chaque créature devra avoir un historique (commun pour toute les instances) contenant des informations.
   Par exemple, avoir une liste contenant l'id des créatures qui ont été manger.
   Avoir une liste contenant l'id des créatures qui l'ont mangé.
   
   Ceci pour avoir des données pour prendre de meilleures décisions.
   
   De plus, chaque créature aura une méthode qui retournera une estimation de sa `dangerosité'.
   Ceci sera uniquement pour donner une idée. Et ne tienderas pas tout en compte.
   Et donc, cette méthode va permettre aux autres créatures d'avoir une idée de l'animositée de celle-la.
   
*** Fonction
    Malheureusement, le travail avec des librairies impose quelques contraintes.
    Une de celles-ci, étant que seulement des fonctions peuvent êtres éxposé d'une librairie au runtime.
    Donc, chaque librairie devra crée une fonction qui sera appellé pour créer une nouvelle créature.

*** Aide à la vue
    Les créatures auront comme responsabilitée de retourner des éléments graphiques.
    En effet, le controlleur ayant aucune idée de la structure interne d'aucune
    créature, ne peut assumer la présence d'aucun atribut.
    
    Donc, chaque créature devra produire des éléments graphiques.
    Par exemple, chaque créature doit retourner un graphique représentant
    l'évolution de ses capacitées.
    Ainsi qu'une interface pour les modifier.
    
*** Modèle
    Chaque librairie sera représentée par un objet.
    Contenant, un id, le handler de la librairie, le nom de cette librairie (sans l'extension),
    et le pointeur de la fonction de construction.
    
    Chaque créature aura un champ `id' qui sera le meme que celui de l'objet d'enregistrement.
    Ceci, dans le but d'avoir des informations sur le type de l'objet.

*** Controlleur
    Lors de chaque `tick', la méthode d'update de chaque Creature sera appellé.
    Le temps de chaque `tick' sera variable, selon la vitesse choisie par l'utilisateur.
    
    À chaque `tick', une double boucle sera effectuée.
    Une première sur chaque élément de la liste.
    Et une autre, interne. Pour voir si le premier peut interagir avec le second.

    La méthode `update' sera appellé avant d'entammer la seconde boucle.
    Cette méthode retournera une valeur pour savoir si la créature à besoin
    d'intéragir avec une autre autour d'elle.

    Si il est possible de construire une sous liste, qui contiendera seulement
    les créatures visibles par la première. Ceci sans avoir à traverser la liste
    une seconde fois, ce sera fait. Pour l'instant, O(n²).

    Ensuite, si jamais la première créature veut intéragir.
    La méthode `doSomethingWith' de la créature sera appellée.
    Laissant celle-ci faire ce qu'elle veut faire.

    Ceci, dans un but d'éviter, autant que possible, un comportement O(n²)
    obligatoire pour chaque Créature.

*** Combat
    Les combat seront gérés de la façon suivante:
    Chaque Créature aura une force d'attaque et un niveau de défense.
    Ceux-ci seront utilisé lors des calculs de combat.
    La formule sera:
	c2.health -= c1.attaque - c2.defense
    health, bien entendu sera >= 0 en tout temps.

    Creature va implémenter la méthode de combat. Donc les créatures spécifiques n'ont pas à le faire.
    Cette méthode va demander à chaque tour de combat si la créature en question veut continuer le combat ou pas.
    Si le combat continue, les dégats seront calculés et retirés de chacunes des créatures.
  
    Le combat se termine, soit quand une des deux prend la fuite, ou bien, quand une des deux meurt.

*** Mort d'une créature
    Lort de la mort d'une Créature, elle se transforme en Nourriture.
    La Nourriture se dégrade avec le temps.
    À chaque `tick' la nourriture va perdre un peu de son contenu. Jusqu'à atteindre le 0, et disparaitre.
    Losrqu'une Créature se nourrira sur de la Nourriture, une quantité du contenue de la Nourriture sera transferée dans la Créature.

** Vue
   La vue sera composée de plusieurs `window'. Qui seront appellé au bon moment par les objets concernés.
   Le point d'entré qui refraichira toute la vue est le `MainWindow'. Qui rafraichira les Widgets en fonction des besoins.
   Celui-ci va rafraichir le GameCanvas avec les nouvelles informations du modele.
   Le canevas central du jeu contiendera des QGraphicsItem, et sera un gros QPainter avec un QGraphicScene.
   
   Le `MainWindow' possedera un `backbuffer' pour contenir l'entiereté du terrain.
   Et seulement une partie de ce `backbuffer' sera affiché à un moment donné.
   Ce qui va permettre de simplifier le déplacement sur la carte ainsi que le zoom.

*** DNAGraph
    Cet objet servira de base pour afficher les données statistiques de chaque Créature.
    Comme il est impossible de connaitre qu'elle donnée sera importante pour chacune des Créatures.
    DNAGraph sera une extension de QXYSeries qui simplifiera la création de graphique.
    
    Il sera donc possible d'ajouter des lignes sur les axes pour avoir un graphe contenant des informations complèxes.

*** DNAChanger
    Cet object à pour but de définir une interface pour le changement de certains atributs des Créatures.
    Par exemple, si l'utilisateur séléctionne une Créature C, il sera apte de voir avec précision son `ADN'.
    C'est-à-dire le contenu de ses atributs qui définissent son comportement.
    Ainsi que d'avoir directement le contrôle sur les données comportomentales de C.

